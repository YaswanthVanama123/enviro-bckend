// src/models/Log.js
// ✅ SIMPLIFIED: Separate Logs collection for version change logs (TXT files)
import mongoose from "mongoose";

// Individual change schema for a single field modification
const FieldChangeSchema = new mongoose.Schema({
  // Product/Service identification
  productKey: {
    type: String,
    required: [true, 'Product key is required']
  },

  productName: {
    type: String,
    required: [true, 'Product name is required']
  },

  productType: {
    type: String,
    enum: ['product', 'dispenser', 'service'],
    required: [true, 'Product type is required']
  },

  // Field change details
  fieldType: {
    type: String,
    required: [true, 'Field type is required']
  },

  fieldDisplayName: {
    type: String,
    required: [true, 'Field display name is required']
  },

  // Value changes
  originalValue: {
    type: Number,
    required: [true, 'Original value is required']
  },

  newValue: {
    type: Number,
    required: [true, 'New value is required']
  },

  changeAmount: {
    type: Number,
    required: [true, 'Change amount is required']
  },

  changePercentage: {
    type: Number,
    required: [true, 'Change percentage is required']
  },

  // Context information
  quantity: {
    type: Number,
    default: 0
  },

  frequency: {
    type: String,
    default: ''
  },

  timestamp: {
    type: String,
    default: () => new Date().toISOString()
  }
}, { _id: false });

// Main Log schema (stores TXT file metadata and content)
const LogSchema = new mongoose.Schema(
  {
    // Document/Version association
    agreementId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'CustomerHeaderDoc',
      required: [true, 'Agreement ID is required'],
      index: true
    },

    agreementTitle: {
      type: String,
      default: ''
    },

    versionId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'VersionPdf',
      required: [true, 'Version ID is required'],
      index: true
    },

    versionNumber: {
      type: Number,
      required: [true, 'Version number is required']
    },

    // File information
    fileName: {
      type: String,
      // ✅ FIXED: Not required since it's auto-generated by pre-save middleware
    },

    fileSize: {
      type: Number,
      default: 0
    },

    contentType: {
      type: String,
      default: 'text/plain'
    },

    // User information
    salespersonId: {
      type: String,
      required: [true, 'Salesperson ID is required'],
      index: true
    },

    salespersonName: {
      type: String,
      required: [true, 'Salesperson name is required']
    },

    // All changes made in this version
    changes: {
      type: [FieldChangeSchema],
      default: []
    },

    // Summary statistics
    totalChanges: {
      type: Number,
      default: 0
    },

    totalPriceImpact: {
      type: Number,
      default: 0
    },

    hasSignificantChanges: {
      type: Boolean,
      default: false
    },

    // Action context
    saveAction: {
      type: String,
      enum: ['save_draft', 'generate_pdf', 'manual_save'],
      required: [true, 'Save action is required']
    },

    documentTitle: {
      type: String,
      required: [true, 'Document title is required']
    },

    // Session information
    sessionId: {
      type: String,
      default: () => `session_${Date.now()}_${Math.random().toString(36).slice(2)}`
    },

    // Soft delete
    isDeleted: {
      type: Boolean,
      default: false
      // Note: Index defined explicitly below
    },

    deletedAt: {
      type: Date,
      default: null
    },

    deletedBy: {
      type: String,
      default: null
    }
  },
  {
    timestamps: true,
    minimize: false
  }
);

// Pre-save middleware to calculate summary statistics and file metadata
LogSchema.pre('save', function(next) {
  if (this.changes && this.changes.length > 0) {
    this.totalChanges = this.changes.length;

    // Calculate total price impact
    this.totalPriceImpact = this.changes.reduce((total, change) => {
      return total + Math.abs(change.changeAmount);
    }, 0);

    // Check for significant changes (>15% or >$50)
    this.hasSignificantChanges = this.changes.some(change => {
      return Math.abs(change.changePercentage) > 15 || Math.abs(change.changeAmount) > 50;
    });
  }

  // Generate file name if not set
  if (!this.fileName) {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
    this.fileName = `Version_${this.versionNumber}_Changes_${timestamp}.txt`;
  }

  // Calculate approximate file size (for TXT content)
  const textContent = this.generateTextContent();
  this.fileSize = Buffer.byteLength(textContent, 'utf8');

  next();
});

// Method to generate TXT file content
LogSchema.methods.generateTextContent = function() {
  const timestamp = new Date(this.createdAt || Date.now()).toISOString();
  const date = new Date(this.createdAt || Date.now()).toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  });

  let content = '';
  content += '='.repeat(80) + '\n';
  content += '                    VERSION CHANGE LOG\n';
  content += '='.repeat(80) + '\n\n';

  // ✅ FIXED: Show Agreement/Customer Name prominently
  if (this.agreementTitle) {
    content += `CUSTOMER/AGREEMENT: ${this.agreementTitle}\n`;
    content += '-'.repeat(80) + '\n\n';
  }

  // Header Information
  content += `Document Title: ${this.documentTitle || 'Untitled Document'}\n`;
  content += `Agreement ID: ${this.agreementId}\n`;
  content += `Version ID: ${this.versionId}\n`;
  content += `Version Number: v${this.versionNumber}\n`;
  content += `Save Action: ${this.saveAction.toUpperCase().replace('_', ' ')}\n`;
  content += `Timestamp: ${date}\n`;
  content += `Salesperson: ${this.salespersonName} (${this.salespersonId})\n\n`;

  // Summary Statistics
  const totalChanges = this.changes.length;
  const totalPriceImpact = this.totalPriceImpact || 0;
  const significantChanges = this.changes.filter(change =>
    Math.abs(change.changeAmount || 0) >= 50 || Math.abs(change.changePercentage || 0) >= 15
  );

  content += '-'.repeat(80) + '\n';
  content += '                        SUMMARY\n';
  content += '-'.repeat(80) + '\n';
  content += `Total Changes Made: ${totalChanges}\n`;
  content += `Total Price Impact: $${totalPriceImpact.toFixed(2)}\n`;
  content += `Significant Changes: ${significantChanges.length} (≥$50 or ≥15%)\n`;
  content += `Review Status: ${significantChanges.length > 0 ? 'REQUIRES REVIEW' : 'AUTO-APPROVED'}\n\n`;

  if (this.changes.length === 0) {
    content += '-'.repeat(80) + '\n';
    content += '                     NO CHANGES DETECTED\n';
    content += '-'.repeat(80) + '\n';
    content += 'No price overrides or modifications were made during this save.\n\n';
  } else {
    // Detailed Changes
    content += '-'.repeat(80) + '\n';
    content += '                    DETAILED CHANGES\n';
    content += '-'.repeat(80) + '\n\n';

    // Group changes by product/service
    const changesByProduct = {};
    this.changes.forEach(change => {
      if (!changesByProduct[change.productName]) {
        changesByProduct[change.productName] = [];
      }
      changesByProduct[change.productName].push(change);
    });

    let changeIndex = 1;
    Object.keys(changesByProduct).forEach(productName => {
      const productChanges = changesByProduct[productName];

      content += `${changeIndex}. ${productName}\n`;
      content += `   Type: ${productChanges[0].productType.toUpperCase()}\n`;
      if (productChanges[0].quantity) {
        content += `   Quantity: ${productChanges[0].quantity}\n`;
      }
      if (productChanges[0].frequency) {
        content += `   Frequency: ${productChanges[0].frequency}\n`;
      }
      content += '\n';

      productChanges.forEach(change => {
        const isSignificant = Math.abs(change.changeAmount || 0) >= 50 || Math.abs(change.changePercentage || 0) >= 15;
        const indicator = isSignificant ? '⚠️  SIGNIFICANT' : '✓  Minor';

        content += `   • ${change.fieldDisplayName}:\n`;
        content += `     Original: $${(change.originalValue || 0).toFixed(2)}\n`;
        content += `     New: $${(change.newValue || 0).toFixed(2)}\n`;
        content += `     Change: ${change.changeAmount >= 0 ? '+' : ''}$${(change.changeAmount || 0).toFixed(2)} `;
        content += `(${change.changeAmount >= 0 ? '+' : ''}${(change.changePercentage || 0).toFixed(1)}%) ${indicator}\n\n`;
      });

      changeIndex++;
    });

    // Significant Changes Warning
    if (significantChanges.length > 0) {
      content += '-'.repeat(80) + '\n';
      content += '                  ⚠️  SIGNIFICANT CHANGES DETECTED\n';
      content += '-'.repeat(80) + '\n';
      content += 'The following changes exceed the significance threshold (≥$50 or ≥15%):\n\n';

      significantChanges.forEach((change, index) => {
        content += `${index + 1}. ${change.productName} - ${change.fieldDisplayName}\n`;
        content += `   Change: ${change.changeAmount >= 0 ? '+' : ''}$${(change.changeAmount || 0).toFixed(2)} `;
        content += `(${change.changeAmount >= 0 ? '+' : ''}${(change.changePercentage || 0).toFixed(1)}%)\n\n`;
      });

      content += 'These changes may require manager approval before finalizing.\n\n';
    }
  }

  // Footer
  content += '='.repeat(80) + '\n';
  content += '                      END OF LOG\n';
  content += '='.repeat(80) + '\n';
  content += `Generated on: ${timestamp}\n`;
  content += 'This log file contains a complete record of all pricing changes made during form editing.\n';

  return content;
};

// Indexes for efficient querying
LogSchema.index({ agreementId: 1, versionNumber: -1 });
LogSchema.index({ agreementId: 1, createdAt: -1 });
LogSchema.index({ versionId: 1 });
LogSchema.index({ salespersonId: 1, createdAt: -1 });
LogSchema.index({ isDeleted: 1 });

// Compound index for grouped folder display
LogSchema.index({
  agreementId: 1,
  versionNumber: -1,
  createdAt: -1
});

// Static methods for querying
LogSchema.statics.getLogsForAgreement = function(agreementId, options = {}) {
  const filter = {
    agreementId: new mongoose.Types.ObjectId(agreementId),
    isDeleted: { $ne: true }
  };

  if (options.versionNumber) {
    filter.versionNumber = options.versionNumber;
  }

  if (options.salespersonId) {
    filter.salespersonId = options.salespersonId;
  }

  return this.find(filter)
    .sort({ versionNumber: -1, createdAt: -1 })
    .limit(options.limit || 100)
    .lean();
};

const Log = mongoose.model("Log", LogSchema);

export default Log;
